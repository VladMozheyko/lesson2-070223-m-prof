import array.ArrayWorking;
import cars.*;

public class Main {

    /*
    План занятия
    1) Продолжаем наследование
    2) Интерфейсами
     */

     /*
     Теория
     Интерфейсы относятся к классами(т.е. типам), но они абсолютно абстрактные, т.е. имеют только абстрактные методы.
     Интерфейс тоже относится к программированию по контракту, т.е. обязует своего наследника реализовать определенный
     функционал.
     Интерфейсы(абсолютно абстрактные классы) нужны для реализации множественного наследования в Java, т.е. унаследоваться
     от нескольких обычных классов нельзя по причине возможного возникновения конфликта между данными класса, например:
     class Car{
      void drive(){
      System.out.println("speed: 180");
      }
     }

     class Bike{
     void drive(){
     System.out.println("speed: 100);
     }
     }

     Если унаследоваться от класса Car и Bike, то по факту класс ребенок получит оба метода и между ними возникнет конфликт,
     чтобы избежать такой ситуации множественное наследование реализовано через интерфейсы, т.е. даже если в классе потомке
     будут методы с таким же названием как в интерфейсе программирование по контракту обяжет потомка самостоятельно реализовать
     этот метод и компилятор будет знать к какой реализации ему обращаться.

     На помощь в такой ситуации придут интерфейсы

     Чтобы определить интерфейс нужно воспользоваться словом interface и в теле класса указать абстрактные методы, т.е.
     единственное отличие интерфейса от класса в ключевом слове и том, что все методы интерфейса абстрактные.
     Для наследования от интерфейса указывается слово implement, если нужно реализовать(унаследовать) несколько интерфейсов,
     они указываются через запятую, например:

     class Worker extends Human implements Runnable, ActionListener{

     }

     Класс Worker наследуется от класса Human и реализует интерфейс Runnable и ActionListener

     Передача функционала возможна не только средствами наследования, но и средствами создания объекта, т.е. при создании
     объекта мы тоже передаем функционал класса такой прием называется композицией. Если есть возможность не пользоваться
     наследованием, то пользуйтесь композицией.

     Иногда нужно запретить изменять класс, метод или переменную. Для этого существует модификатор final. final - константа
     Указывая переменную с модификатором final мы запрещаем ее изменять, метод запрещаем переопределят, класс запрещаем
     наследовать

     */

     /*
    Заметки
    В качестве примера библиотечных классов где представлена возможность множественного наследования можно привести
    класс Thread и интерфейс Runnable, два класса нужны для того, чтобы программист всегда мог унаследовать функционал
    многопоточности, даже если у его класса уже есть класс родитель

     */

     /*
    Задачи со звездочкой

     */


  static final int CONST = 10;            // Константая переменная
    public static void main(String[] args) {
        BMW bmw = new BMW("X5");
        bmw.drive();
        bmw.turnOn();
        bmw.stop();
        Lamborghini lamborghini = new Lamborghini("diablo");
        lamborghini.drive();
        lamborghini.turnOn();
        lamborghini.stop();
        lamborghini.fly();

        Car car = new Car("Жигули") {      // Анонимный класс - реализация контракта на месте, для создания экземпляра абстрактного класса
            @Override                      // или интерфейса
            public void turnOn() {
                System.out.println(getTitle() + " возможно заведется");
            }

            @Override
            public void stop(){
                System.out.println(getTitle() + " ну посмотрим, может не сразу, но когда-нибудь остановимся.");
            }
        };

        car.drive();
        car.turnOn();
        car.stop();

        Car car1 = new Car("Форд") {
            @Override
            public void turnOn() {
               System.out.println(getTitle() + "старая машина, тоже заводится через ключ");
            }

            @Override
            public void stop(){
                System.out.println(getTitle() + " прекратить движение");
            }
        };

        car1.turnOn();
        car1.drive();
        car1.stop();
        System.out.println(Driveable.myClass);

        Tesla tesla = new Tesla("Тесла");
        tesla.turnOn();
        tesla.drive();
        tesla.stop();
        tesla.fly();

        Car car2 = new Tesla("Тесла");   // У потомка всегда будет требуемый функционал для создания объекта родителя
        car2.fly();
       // Tesla tesla1 = (Tesla)new Object();    //  Потомок расширяет класс родителя, поэтому обратно по шаблону потомка нельзя создать объект родителя, т.к. у родителя может не быть требуемого функционала


        System.out.println("" + " " + tesla + " " + 1 + " " +  2 );
        print(1, 2, 3, 3, 4, 2, 6, 7, " Привет", tesla, 1.2, 'c', true);

        System.out.println();
        ArrayWorking arrayWorking = new ArrayWorking();
        arrayWorking.add(1);
        arrayWorking.add("Hello");
        arrayWorking.add(tesla);
        arrayWorking.add(true);
        arrayWorking.add(12.4);
        arrayWorking.display();
        System.out.println("Удалил массив: ");
        arrayWorking.delete();
        arrayWorking.display();
        System.out.println("Взломали массив: ");
        arrayWorking.hack();
        arrayWorking.display();
        arrayWorking.erase();
        System.out.println("Стерли массив : ");
        arrayWorking.display();
        System.out.println("Снова взломали массив : ");
        arrayWorking.hack();
        arrayWorking.display();

    }
              // В методе при получение произвольного количества параметров создается массив, в котором они хранятся
    public static void print(Object ... a){    // Позволяет принимать произвольное количество параметров и преобразует их в массив a
        for (int i = 0; i <a.length ; i++) {
            System.out.print(a[i] + " ");
        }
    }

    /*
    Задача
    Реализовать класс для работы с массивом произвольного типа
    Решение
    Класс делаем по аналогии с задачами из basic для массива конкретного типа, но вместо
    конкретного типа используем Object
     */
}
